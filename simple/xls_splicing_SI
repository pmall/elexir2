#!/usr/bin/perl
use warnings;
use strict;
use YAML::XS qw(LoadFile);
use DBI;
use File::Path qw(make_path);
use Spreadsheet::WriteExcel;
use FindBin qw($Bin);
use lib "$FindBin::Bin/../lib";
use Format;
use Math;
use Analyse;

# ==============================================================================
# Parametres
# ==============================================================================

# On récupère l'id du projet a analyser
my $id_analyse = shift @ARGV || die('Vous devez passer l\'id d\'une analyse en paramètre');

# On récupère un hash de config
my $config = LoadFile($FindBin::Bin . '/../config.yml');

# On défini les identifiants pour la bdd
my $db_host = $config->{'db_host'};
my $db_user = $config->{'db_user'};
my $db_pass = $config->{'db_pass'};
my $db_name = $config->{'db_name'};

# Paramètres de sélection pour les résulats
my $seuil_epissage = $config->{'simple'}{'excel'}{'seuil_epissage'};
my $seuil_pval = $config->{'simple'}{'excel'}{'seuil_pval'};
my $seuil_fiabilite_fcGene = $config->{'simple'}{'excel'}{'seuil_fc_gene'};

# Répertoire de sortie 
my $dir_xls = $config->{'dir_xls'};

# ==============================================================================
# On récupère les infos de l'analyse
# ==============================================================================

my $dbh = DBI->connect(
	"DBI:mysql:" . $db_name . ":" . $db_host,
	$db_user,
	$db_pass
);

my $analyse = Analyse->get_analyse($dbh, $id_analyse);

die('L\'id de l\'analyse n\'est pas valide.') if(!$analyse);

# Message d'erreur si c'est pas le bon script pour le bon type d'analyse
if($analyse->{'type'} ne 'simple'){

	die('Le script simple ne fonctionne que sur les analyses simples :o)');

}

# ==============================================================================
# On récupère les infos dont on a besoin selon les infos de l'analyse
# ==============================================================================

# On récupère les infos de la bdd
my $id_projet = $analyse->{"id_project"};
my $type_chips = $analyse->{'type_chips'};
my $version = $analyse->{'version'};
my $orga = $analyse->{'organism'};
my $name = $analyse->{'name'};
my $paire = $analyse->{'paired'};
my $nb_paires_rep = $analyse->{'nb_paires_rep'};

# on crée les variables du script qui déendent de l'analyse
my $table_genes = $config->{'table_genes'}{$version}{$orga};
my $table_entites = $config->{'table_entites'}{$version}{$orga};
my $table_trans = get_table_transcription($id_projet, $id_analyse);
my $table_splicing = get_table_splicing($id_projet, $id_analyse);
my $dir_sortie = $dir_xls . '/' . $id_projet . '/' . $id_analyse;
my $fichier_sortie = $dir_sortie . '/' . $name . '_epissage_SI.xls';

# On crée les dossier
make_path($dir_sortie);

# ==============================================================================
# On se connecte a fasterdb
# ==============================================================================

my $select_entites_nofdr_sth = $dbh->prepare(
	"SELECT e.*, g.epi_fc, g.epi_pval, g.epi_nb_sondes, g.epi_nb_exons
	FROM $table_trans AS g, $table_splicing AS e
	WHERE g.id_gene = e.id_gene
	AND ABS(LOG2(SI)) >= LOG2(?)
	AND SI_pval <= ?
	AND is_robust = 1"
);

my $select_entites_fdr_sth = $dbh->prepare(
	"SELECT e.*, g.epi_fc, g.epi_pval, g.epi_nb_sondes, g.epi_nb_exons,
	e.SI_adjp AS SI_pval
	FROM $table_trans AS g, $table_splicing AS e
	WHERE g.id_gene = e.id_gene
	AND ABS(LOG2(SI)) >= LOG2(?)
	AND SI_adjp <= ?
	AND is_robust = 1"
);

my $select_infos_gene_sth = $dbh->prepare(
	"SELECT * FROM $table_genes WHERE id_fasterdb = ?"
);

my $select_infos_entite_sth = $dbh->prepare(
	"SELECT id, type, exon_pos, start_sur_gene, end_sur_gene
	FROM $table_entites
	WHERE id = ?"
);

# ==============================================================================
# Initialisation fichier excel
# ==============================================================================

# Fichier
my $xlsh			= Spreadsheet::WriteExcel->new($fichier_sortie);

# Feuilles
my $f_resume			= $xlsh->add_worksheet('Parametres et entites analysees');
my $f_epissage_no_fdr		= $xlsh->add_worksheet('NO FDR');
my $f_epissage_fdr		= $xlsh->add_worksheet('FDR');

# Couleurs
my $couleur_entete		= $xlsh->set_custom_color(39, 189, 189, 189);

# Formats
my $format_resume_titre		= $xlsh->add_format(color => 'black', bold => 1, center_across => 1);
my $format_resume_intermediaire	= $xlsh->add_format(color => 'black', italic => 1, center_across => 1);
my $format_resume_cell		= $xlsh->add_format(color => 'black', bold => 0, center_across => 1);
my $format_merge_entete		= $xlsh->add_format(color => 'black', bold => 1, bg_color => $couleur_entete, border => 2, border_color => 'black', center_across => 1);
my $format_entete		= $xlsh->add_format(color => 'black', bold => 1, bg_color => $couleur_entete, border => 2, border_color => 'black', center_across => 1);
my $format_cell			= $xlsh->add_format(color => 'black', border => 1, border_color => 'black', center_across => 1);
my $format_cell_mauv_fc		= $xlsh->add_format(color => 'red', border => 1, border_color => 'black', center_across => 1);
my $format_cell_no_center	= $xlsh->add_format(color => 'black', bold => 0);

# ==============================================================================
# Feuille résumé
# ==============================================================================

# Infos de base
$f_resume->write(0, 0, date(), $format_cell_no_center);
$f_resume->write(2, 0, "Parametres utilises", $format_resume_titre);
$f_resume->write(3, 0, "Seuil fold", $format_resume_titre);
$f_resume->write(3, 1, round($seuil_epissage, 2), $format_resume_titre);
$f_resume->write(4, 0, "Seuil p-value", $format_resume_titre);
$f_resume->write(4, 1, $seuil_pval, $format_resume_titre);

# ==============================================================================
# On ajoute les entités dans les feuilles
# ==============================================================================

my @entites = ();

# On selectionne les entites no fdr
$select_entites_nofdr_sth->execute($seuil_epissage, $seuil_pval);
@entites = @{$select_entites_nofdr_sth->fetchall_arrayref({})};
$select_entites_nofdr_sth->finish;

my($nb_nofdr_up, $nb_nofdr_down) = write_list($f_epissage_no_fdr, @entites);

# On selectionne les entites fdr
$select_entites_fdr_sth->execute($seuil_epissage, $seuil_pval);
@entites = @{$select_entites_fdr_sth->fetchall_arrayref({})};
$select_entites_fdr_sth->finish;

my($nb_fdr_up, $nb_fdr_down) = write_list($f_epissage_fdr, @entites);

# ==============================================================================
# Fonction pour remplir la feuille
# ==============================================================================

sub write_list{

	my($f, @entites) = @_;

	my $nb_gene = 0;
	my $gene_id_prec = 0;
	my $nb_ups = 0;
	my $nb_downs = 0;

	# On défini les entete groupées

	my $o = ($paire) ? $nb_paires_rep : 0; # Offset nombre de paires de rep

	$f->merge_range(0, 1, 0, 8, 'Infos gene', $format_merge_entete);
	$f->merge_range(0, 9, 0, 13, 'Infos entite', $format_merge_entete);
	$f->merge_range(0, 14, 0, 16, 'Reg gene', $format_merge_entete);
	$f->merge_range(0, 17, 0, 19 + $o, 'Reg SI', $format_merge_entete);
	$f->merge_range(0, 20 + $o, 0, 21 + $o, 'Other algorithms', $format_merge_entete);

	# On défini les entetes de chaque colonnes

	my @SIs = ();

	if($paire){

		for(my $i = 0; $i < $nb_paires_rep; $i++){

			push(@SIs, 'SI' . ($i + 1));

		}

	}

	my @entetes = ();

	push(@entetes, 'Gene');

	# Infos du gène
	push(@entetes, 'Fasterdb id');
	push(@entetes, 'Source id');
	push(@entetes, 'Link Elexir');
	push(@entetes, 'Symbol');
	push(@entetes, 'Description');
	push(@entetes, 'Chr Position');
	push(@entetes, 'Nb probes');
	push(@entetes, 'Nb exons');

	# Infos entité
	push(@entetes, 'Elexir id');
	push(@entetes, 'AS Event Type');
	push(@entetes, 'Exon position');
	push(@entetes, 'Nb probes');
	push(@entetes, 'AS Event Sequence');

	# Reg gène
	push(@entetes, 'Regulation');
	push(@entetes, 'FC');
	push(@entetes, 'Pvalue');

	# Reg SI
	push(@entetes, 'Regulation');
	push(@entetes, @SIs) if($paire);
	push(@entetes, 'Med SI');
	push(@entetes, 'Pvalue');

	# Autres alogs
	push(@entetes, 'SIsd');
	push(@entetes, 'psi');

	for(my $j = 0; $j < @entetes; $j++){

		$f->write(1, $j, $entetes[$j], $format_entete);

	}

	# Fonction qui retourne 1 si l'entité est valide pour les trois types
	sub commun{

		my($entite) = @_;

		return(
			((format_fold($entite->{'SIsd'}) >= $seuil_epissage) and ($entite->{'SIsd_pval'} <= $seuil_pval))
			and
			((format_fold($entite->{'psi_fc'}) >= $seuil_epissage) and ($entite->{'psi_pval'} <= $seuil_pval))
		);

	}

	# On classe les entites
	@entites = sort {
		# On classe déjà les communs en premier
		commun($b) <=> commun($a)
		||
		# Ensuite par FC gène fiable
		(format_fold($b->{'epi_fc'}) <= $seuil_fiabilite_fcGene)
		<=>
		(format_fold($a->{'epi_fc'}) <= $seuil_fiabilite_fcGene)
		||
		# Ensuite par gène
		$a->{'id_gene'} <=> $b->{'id_gene'}
	} @entites;

	my $nb_lignes = 2;

	# Pour chaque entité
	for(my $i = 0; $i < @entites; $i++){

		my $entite = $entites[$i];

		# On récupère les infos du gène
		$select_infos_gene_sth->execute($entite->{'id_gene'});
		my $infos_gene = $select_infos_gene_sth->fetchrow_hashref;
		$select_infos_gene_sth->finish;

		# On récupère les infos de l'entité
		$select_infos_entite_sth->execute($entite->{'id_entite'});
		my $infos_entite = $select_infos_entite_sth->fetchrow_hashref;
		$select_infos_entite_sth->finish;

		# On met a jour le numéro du gène
		if($infos_gene->{'id_fasterdb'} != $gene_id_prec){

			$nb_gene++;

			$gene_id_prec = $infos_gene->{'id_fasterdb'};

		}

		# On compte les up et les down
		($entite->{'SI'} >= 1) ? $nb_ups++ : $nb_downs++;

		my $pos_chrom =
			$infos_gene->{'chromosome'} .
			':' . $infos_gene->{'start_sur_chromosome'} .
			'-' . $infos_gene->{'end_sur_chromosome'} .
			':' . $infos_gene->{'strand'};

		my $prefix_pos = ($infos_entite->{'type'} eq 'intron-retention')
			? 'i' : 'e' ;

		my $pos_entite =
			$prefix_pos . $entite->{'exon_pos'} .
			':' . $infos_entite->{'start_sur_gene'} .
			'-' . $infos_entite->{'end_sur_gene'};

		my $reg_gene = ($entite->{'epi_fc'} >= 1) ? 'up' : 'down';
		my $reg_SI = ($entite->{'SI'} >= 1) ? 'up' : 'down';

		my $format = (format_fold($entite->{'epi_fc'}) <= $seuil_fiabilite_fcGene)
			? $format_cell
			: $format_cell_mauv_fc;

		my $SIsd_ok = ((format_fold($entite->{'SIsd'}) >= $seuil_epissage) and ($entite->{'SIsd_pval'} <= $seuil_pval));
		my $psi_ok = ((format_fold($entite->{'psi_fc'}) >= $seuil_epissage) and ($entite->{'psi_pval'} <= $seuil_pval));

		# On crée le tableau de data
		my @data = ();

		push(@data, $nb_gene);

		# Infos du gène
		push(@data, $infos_gene->{'id_fasterdb'});
		push(@data, $infos_gene->{'id_source'});
		push(@data, 'blah');
		push(@data, $infos_gene->{'symbol'});
		push(@data, $infos_gene->{'description'});
		push(@data, $pos_chrom);
		push(@data, $entite->{'epi_nb_sondes'});
		push(@data, $entite->{'epi_nb_exons'});

		# Infos entité
		push(@data, $infos_entite->{'id'});
		push(@data, $infos_entite->{'type'});
		push(@data, $pos_entite);
		push(@data, $entite->{'nb_sondes'});
		push(@data, 'seq');

		# Regulation gène
		push(@data, $reg_gene);
		push(@data, format_fold($entite->{'epi_fc'}));
		push(@data, $entite->{'epi_pval'});

		# Algo SI
		push(@data, $reg_SI);
		push(@data, map { $entite->{$_} } @SIs) if($paire);
		push(@data, format_fold($entite->{'SI'}));
		push(@data, $entite->{'SI_pval'});

		# Autres algos
		push(@data, ($SIsd_ok) ? 'X' : '');
		push(@data, ($psi_ok) ? 'X' : '');

		# On affiche les data
		for(my $j = 0; $j < @data; $j++){

			# $i + 1 parce que la premiere ligne est l'entete
			$f->write($nb_lignes, $j, $data[$j], $format);

		}

		$nb_lignes++;

	}

}
