#!/usr/bin/perl
use warnings;
use strict;
use YAML::XS qw(LoadFile);
use DBI;
use List::Util qw(sum);
use File::Temp qw(tempdir);
use FindBin qw($Bin);
use lib $FindBin::Bin . '/../lib';
use Format;
use Math;
use Analyse;
use Stats;

# ==============================================================================
# Parametres
# ==============================================================================

# On récupère l'id du projet a analyser
my $id_analyse = shift @ARGV || die('Vous devez passer l\'id d\'une analyse en paramètre');

# On récupère un hash de config
my $config = LoadFile($FindBin::Bin . '/../config.yml');

# On défini les identifiants pour la bdd
my $db_host = $config->{'db_host'};
my $db_user = $config->{'db_user'};
my $db_pass = $config->{'db_pass'};
my $db_name = $config->{'db_name'};

# On défini un dossier temporaire
my $tmp_dir = tempdir(CLEANUP => 1);

# On défini les fichiers
my $file_ni = $tmp_dir . '/ni';
my $file_si = $tmp_dir . '/si';

# Pour supprimer le dossier temporaire lors de ctrl+C
$SIG{INT} = sub{ exit; };

# ==============================================================================
# Préparation des requètes
# ==============================================================================

# On se connecte a elexir
my $dbh = DBI->connect(
	'DBI:mysql:' . $db_name . ':' . $db_host,
	$db_user,
	$db_pass
);

# On selectionne les infos de l'analyse
my $select_infos_analyse_sth = $dbh->prepare(
	"SELECT p.id AS id_project, p.type AS type_chips, p.organism, a.type
	FROM analyses AS a, projects AS p
	WHERE a.id_project = p.id
	AND a.id = ?"
);

# On selectionne les conditions du projet
my $select_chips_sth = $dbh->prepare(
	"SELECT g.letter, c.condition, c.num
	FROM groups AS g, chips AS c
	WHERE g.condition = c.condition
	AND g.id_analysis = ?"
);

# ==============================================================================
# On teste si l'analyse existe bien
# ==============================================================================

$select_infos_analyse_sth->execute($id_analyse);

my $infos_analyse = $select_infos_analyse_sth->fetchrow_hashref;

die('L\'id de l\'analyse n\'est pas valide.') if(!$infos_analyse);

# ==============================================================================
# On crée les noms de table dont on a besoin
# ==============================================================================

my $table_sondes = $config->{'table_sondes'}{$infos_analyse->{'organism'}};
my $table_intensites = get_table_intensites($infos_analyse->{'id_project'});
my $table_trans = get_table_transcription($infos_analyse->{'id_project'}, $id_analyse);
my $table_ni = get_table_ni($infos_analyse->{'id_project'}, $id_analyse);
my $table_si = get_table_si($infos_analyse->{'id_project'}, $id_analyse);

# ==============================================================================
# On prépare les requete pour l'analyse avec ces infos
# ==============================================================================

# On selectionne les gènes qui ont un fc épissage
my $select_genes_sth = $dbh->prepare(
	"SELECT * FROM " . $table_trans . " WHERE epi_fc IS NOT NULL"
);

# On selectionne les sondes d'un gène
my $select_infos_sondes_sth = $dbh->prepare(
	"SELECT probe_id
	FROM " . $table_sondes . "
	WHERE align = 'as'
	AND gene_id = ?"
);

# On selectionne l'intensité d'une sonde
my $select_intensite_sth = $dbh->prepare(
	"SELECT * FROM " . $table_intensites . " WHERE probe_id = ?"
);

# ==============================================================================
# On récupère la description de l'expérience
# ==============================================================================

my @exp = decrire(
	$select_chips_sth,
	$id_analyse,
	$infos_analyse->{'type'}
);

# ==============================================================================
# On crée les tables NIs et SIs
# ==============================================================================

my @fields_NIs = ();
my @fields_SIs = ();

for(my $i = 1; $i <= @exp; $i++){

	my $p = $exp[$i - 1];

	for(my $j = 0; $j < @{$p->{'control'}}; $j++){

		push(@fields_NIs, 'control' . ($i + $j));

	}

	for(my $j = 0; $j < @{$p->{'test'}}; $j++){

		push(@fields_NIs, 'test' . ($i + $j));

	}

	push(@fields_SIs, 'SI' . $i);

}

my @fields_table_NIs = (
	'probe_id INT UNSIGNED NOT NULL',
	'gene_id INT UNSIGNED NOT NULL',
	(map { $_ . ' DECIMAL(10,5) NOT NULL' } @fields_NIs)
);

my @fields_table_SIs = (
	'probe_id INT UNSIGNED NOT NULL',
	'gene_id INT UNSIGNED NOT NULL',
	(map { $_ . ' DECIMAL(10,5) NOT NULL' } @fields_SIs)
);

$dbh->do('DROP TABLE IF EXISTS ' . $table_ni);
$dbh->do('CREATE TABLE ' . $table_ni . ' (' . join(', ', @fields_table_NIs) . ', PRIMARY KEY (probe_id, gene_id))');

$dbh->do('DROP TABLE IF EXISTS ' . $table_si);
$dbh->do('CREATE TABLE ' . $table_si . ' (' . join(', ', @fields_table_SIs) . ', PRIMARY KEY (probe_id, gene_id))');

# ==============================================================================
# On début l'algo, pour chaque gène avec un fc epissage non null
# ==============================================================================

print 'On calcule les valeurs de NI et de SI' . "\n";

my $i = 0;

# On ouvre les fichiers de sortie
open(OUT_NI, '>' . $file_ni);
open(OUT_SI, '>' . $file_si);

# On selectionne les gènes avec un fc épissage non null
$select_genes_sth->execute;

# Pour chaque gène
while(my $gene = $select_genes_sth->fetchrow_hashref){

	print '' . (++$i) . "\n";

	# ======================================================================
	# On récupère les intensités des sondes du gène
	# ======================================================================

	# On récupère les ids des sondes
	$select_infos_sondes_sth->execute($gene->{'gene_id'});
	my $infos_sondes = $select_infos_sondes_sth->fetchall_hashref('probe_id');
	$select_infos_sondes_sth->finish;

	# ======================================================================
	# On calcule les NIs et les SIs des sondes
	# ======================================================================

	foreach my $id_sonde (keys %{$infos_sondes}){

		my @NIs = ();
		my @SIs = ();

		# On selectionne l'intensité de la sonde
		$select_intensite_sth->execute($id_sonde);
		my $sonde = $select_intensite_sth->fetchrow_hashref;
		$select_intensite_sth->finish;

		# pour les NIs et les SIs on soustrait des valeurs en log2
		# parce que log(x) - log(y) = log(x/y)
		for(my $i = 1; $i <= @exp; $i++){

			my $p = $exp[$i - 1];

			foreach(@{$p->{'control'}}){

				push(@NIs, log2($sonde->{$_}) - $gene->{'control' . $i});

			}

			foreach(@{$p->{'test'}}){

				push(@NIs, log2($sonde->{$_}) - $gene->{'test' . $i});

			}

		}

		# On ajoute dans le fichier NI
		print OUT_NI join("\t", ($sonde->{'probe_id'}, $gene->{'gene_id'}, @NIs)) . "\n";

		# On calcule les SIs
		# pour ça il faut récupérer les folds déjà
		my @fcs = fcs_sonde(\@exp, $sonde);

		# Puis on soustrait le fc epissage du gène a chaque fc (en log2)
		foreach(@fcs){ push(@SIs, log2($_) - $gene->{'epi_fc'}) }

		# On ajoute dans le fichier SI
		print OUT_SI join("\t", ($sonde->{'probe_id'}, $gene->{'gene_id'}, @SIs)) . "\n";

	}

}

close(OUT_NI);
close(OUT_SI);

# ==============================================================================
# On ajoute le contenu des fichiers dans la base de données
# ==============================================================================

print 'Ajout des NIs dans la base de données' . "\n";

my $mysql_ni = "mysql -h $db_host -u $db_user -p$db_pass $db_name";
   $mysql_ni.= " -e \"LOAD DATA LOCAL INFILE '$file_ni' INTO TABLE $table_ni\"";

`$mysql_ni`;

print 'Ajout des SIs dans la base de données' . "\n";

my $mysql_si = "mysql -h $db_host -u $db_user -p$db_pass $db_name";
   $mysql_si.= " -e \"LOAD DATA LOCAL INFILE '$file_si' INTO TABLE $table_si\"";

`$mysql_si`;
