#!/usr/bin/perl
use strict;
use warnings;
use FindBin qw($Bin);
use DBI;
use List::MoreUtils qw(uniq);
use Statistics::R;

require $FindBin::Bin . '/fonctions';

# ==============================================================================
# Parametres
# ==============================================================================

# On récupère l'id du projet a analyser
my $id_analyse = shift @ARGV || die('Vous devez passer l\'id d\'une analyse en paramètre');

# Seuil pour le dabg
my $seuil_dabg = 0.05;

# Constante SI significatif
my $const_si = 0.137503524;

# On défini les identifiants pour la bdd
my $db_host = 'localhost';
my $db_name = 'elexir2';
my $db_name_fdb = 'fasterdb_humain';
my $db_user = 'elexir2';
my $db_pass = 'pandas';

# On ouvre une session R pour le script
my $R = Statistics::R->new();
$R->startR;

# ==============================================================================
# Préparation des requètes
# ==============================================================================

# On se connecte a elexir
my $dbh = DBI->connect(
	'DBI:mysql:' . $db_name . ':' . $db_host,
	$db_user,
	$db_pass
);

# On se connecte a fasterdb
my $dbh_fdb = DBI->connect(
	'DBI:mysql:' . $db_name_fdb . ':' . $db_host,
	$db_user,
	$db_pass
);

# On selectionne les infos de l'analyse
my $select_infos_analyse_sth = $dbh->prepare(
	"SELECT p.id AS id_project, p.type AS type_chips, p.organism, a.type
	FROM analyses AS a, projects AS p
	WHERE a.id_project = p.id
	AND a.id = ?"
);

# On selectionne les puces du projet
my $select_chips_sth = $dbh->prepare(
	"SELECT g.letter, c.condition, c.num
	FROM groups AS g, chips AS c
	WHERE g.condition = c.condition
	AND g.id_analysis = ?"
);

# ==============================================================================
# On teste si l'analyse existe bien
# ==============================================================================

$select_infos_analyse_sth->execute($id_analyse);

my $infos_analyse = $select_infos_analyse_sth->fetchrow_hashref;

die('L\'id de l\'analyse n\'est pas valide.') if(!$infos_analyse);

# ==============================================================================
# On crée les noms de table dont on a besoin
# ==============================================================================

my $table_sondes = $infos_analyse->{'organism'} eq 'human'
	? 'humain_probes_status'
	: 'souris_probes_status';
my $table_intensites = '_' . $infos_analyse->{'id_project'} . '_intensites';
my $table_dabg = '_' . $infos_analyse->{'id_project'} . '_dabg';
my $table_trans = '_' . $infos_analyse->{'id_project'} . '__' . $id_analyse . '_transcription';
my $table_sis = '_' . $infos_analyse->{'id_project'} . '__' . $id_analyse . '_SIs';
my $table_splicing = '_' . $infos_analyse->{'id_project'} . '__' . $id_analyse . '_splicing';

# ==============================================================================
# On prépare les requete pour l'analyse avec ces infos
# ==============================================================================

# On selectionne les gènes qui ont un fc épissage
my $select_genes_sth = $dbh->prepare(
	"SELECT * FROM " . $table_trans . " WHERE epi_fc IS NOT NULL"
);

# On selectionne les exons des gènes
my $select_nb_exons_gene_sth = $dbh_fdb->prepare(
	"SELECT COUNT(id) AS nb_exons FROM exons_genomiques WHERE id_gene = ?"
);

# On selectionne les sondes d'un gène
my $select_infos_sondes_sth = $dbh->prepare(
	"SELECT probe_id, exon_pos, entite_id, entite_type
	FROM " . $table_sondes . "
	WHERE align = 'as'
	AND gc_content < 18
	AND nb_occ = 1
	AND gene_id = ?"
);

# On selectionne le dabg d'une sonde
my $select_dabg_sth = $dbh->prepare(
	"SELECT * FROM " . $table_dabg . " WHERE probe_id = ?"
);

# On selectionne l'intensité d'une sonde
my $select_intensite_sth = $dbh->prepare(
	"SELECT * FROM " . $table_intensites . " WHERE probe_id = ?"
);

# On selectionne les SIs du gène
my $select_sis_sth = $dbh->prepare(
	"SELECT * FROM " . $table_sis . " WHERE gene_id = ?"
);

# ==============================================================================
# On récupère la description de l'expérience
# ==============================================================================

my @exp = decrire(
	$select_chips_sth,
	$id_analyse,
	$infos_analyse->{'type'}
);

# ==============================================================================
# On crée dynamiquement la table
# ==============================================================================

# petite raccourcit...
my $paire = ($infos_analyse->{'type'} eq 'paire');

my @fields_expr = ();
my @fields_SIs = ();
my @fields_SIsds = ();

for(my $i = 0; $i < @exp; $i++){

	push(@fields_expr, 'control' . ($i + 1));
	push(@fields_expr, 'test' . ($i + 1));

}

@fields_expr = sort @fields_expr;

for(my $i = 0; $i < @exp; $i++){ push(@fields_SIs, 'SI' . ($i + 1)); }
for(my $i = 0; $i < @exp; $i++){ push(@fields_SIsds, 'SIsd' . ($i + 1)); }

my @fields_splicing = ();

push(@fields_splicing, 'id_entite INT UNSIGNED NOT NULL');
push(@fields_splicing, 'gene_id INT UNSIGNED NOT NULL');
push(@fields_splicing, 'entite_type TINYINT UNSIGNED NOT NULL');
push(@fields_splicing, 'entite_pos SMALLINT UNSIGNED NOT NULL');
push(@fields_splicing, (map { $_ . ' DECIMAL(10,5) UNSIGNED NOT NULL'; } @fields_expr));
push(@fields_splicing, (map { $_ . ' DECIMAL(10,5) NOT NULL' } @fields_SIs)) if($paire);
push(@fields_splicing, 'SI DECIMAL(10,5) NOT NULL');
push(@fields_splicing, 'SI_pval DECIMAL(12,5) NOT NULL');
push(@fields_splicing, 'SI_adjp DECIMAL(12,5) NOT NULL');
push(@fields_splicing, (map { $_ . ' DECIMAL(10,5) NOT NULL' } @fields_SIsds)) if($paire);
push(@fields_splicing, 'SIsd DECIMAL(10,5) NOT NULL');
push(@fields_splicing, 'SIsd_pval DECIMAL(12,5) UNSIGNED NOT NULL') if($paire);
push(@fields_splicing, 'SIsd_adjp DECIMAL(12,5) UNSIGNED NOT NULL') if($paire);
push(@fields_splicing, 'psi_control DECIMAL(15,5) NOT NULL');
push(@fields_splicing, 'psi_sd_control DECIMAL(15,5) NOT NULL') if($paire);
push(@fields_splicing, 'psi_test DECIMAL(15,5) NOT NULL');
push(@fields_splicing, 'psi_sd_test DECIMAL(15,5) NOT NULL') if($paire);
push(@fields_splicing, 'psi_fc DECIMAL(15,5) NOT NULL');
push(@fields_splicing, 'psi_sd_fc DECIMAL(15,5) NOT NULL') if($paire);
push(@fields_splicing, 'psi_pval DECIMAL(12,5) UNSIGNED NOT NULL') if($paire);
push(@fields_splicing, 'psi_adjp DECIMAL(12,5) UNSIGNED NOT NULL') if($paire);
push(@fields_splicing, 'nb_sondes SMALLINT UNSIGNED NOT NULL');
push(@fields_splicing, 'is_robust TINYINT UNSIGNED NOT NULL');

$dbh->do('DROP TABLE IF EXISTS ' . $table_splicing);
$dbh->do('CREATE TABLE ' . $table_splicing . ' (' . join(', ', @fields_splicing) . ', PRIMARY KEY (id_entite, gene_id, entite_type))');

my $insert_entite_sth = $dbh->prepare(
	"INSERT INTO $table_splicing VALUES(" . join(', ', ('?')x@fields_splicing) . ")"
);

# ==============================================================================
# Début de l'algo, on analyse les gènes avec un fc épissage
# ==============================================================================

my $i = 0;

# On défini une liste d'entité (on les garde toutes dans une liste pour calculer
# les pvals ajustés)
my @entites = ();

# On selectionne les gènes
$select_genes_sth->execute;

# Pour chaque gène
while(my $gene = $select_genes_sth->fetchrow_hashref){

	print '' . (++$i) . "\n";

	# ======================================================================
	# On récupère les infos sur les sondes exprimées
	# ======================================================================

	# On récupère le nombre d'exons du gène
	$select_nb_exons_gene_sth->execute($gene->{'gene_id'});
	my($nb_exons) = $select_nb_exons_gene_sth->fetchrow_array;
	$select_nb_exons_gene_sth->finish;

	# On récupère les infos des sondes du gène
	$select_infos_sondes_sth->execute($gene->{'gene_id'});
	my $infos_sondes = $select_infos_sondes_sth->fetchall_arrayref({});
	$select_infos_sondes_sth->finish;

	# On récupère les ids des sondes (la même sonde peut apparaitre plusieur
	# fois dans le gène)
	my @ids_sondes = uniq(map { $_->{'probe_id'} } @{$infos_sondes});

	# On récupère les infos des sondes exprimées
	my @infos_sondes_exprimes = ();

	foreach my $id_sonde (@ids_sondes){

		$select_dabg_sth->execute($id_sonde);
		my $values = $select_dabg_sth->fetchrow_hashref;
		$select_dabg_sth->finish;

		if(dabg($seuil_dabg, \@exp, $values)){

			push(@infos_sondes_exprimes, (grep {
				$_->{'probe_id'} == $values->{'probe_id'}
			} @{$infos_sondes}));

		}

	}

	# ======================================================================
	# On garde que les gènes qui ont moins de 4 exons ou au moins 4 exons
	# avec au moins 2 sondes dans 50% des exons
	# ======================================================================

	# On va garder qu'une partie des sondes du gène
	my @infos_sondes_selectionnes = ();

	# On récupère les sondes exoniques parmis les sondes exprimés
	my @infos_sondes_exons = (grep {
		$_->{'entite_type'} == 1
	} @infos_sondes_exprimes);

	# Si il y a moins de 4 exons on garde tout
	if($nb_exons < 4){

		# On garde toute les sondes
		@infos_sondes_selectionnes = @infos_sondes_exprimes;

	# Sinon on garde le gene seulement si 50% des exons ont au moins deux
	# sondes. On ne garde que les sondes qui sont dans les exons avec au
	# moins deux sondes
	}else{

		# On compte le nombre de sondes uniques par exon
		my %sondes_par_exons = ();

		foreach my $infos_sonde_exon (@infos_sondes_exons){

			$sondes_par_exons{$infos_sonde_exon->{'exon_pos'}}++;

		}

		# On selectionne les exons qui ont au moins 2 sondes
		my @exons_2_sondes = grep {
			$sondes_par_exons{$_} > 1
		} keys %sondes_par_exons;

		# On zappe si il n'y a pas 50% des exons qui ont au moins 2
		# sondes
		next if(@exons_2_sondes < int($nb_exons/2));

		# On ne garde que les sondes des exons qui ont au moins deux sondes
		foreach my $exon_pos (@exons_2_sondes){

			push(@infos_sondes_selectionnes, grep {
				$_->{'exon_pos'} == $exon_pos
			} @infos_sondes_exprimes);

		}

	}

	# ======================================================================
	# Le gène est selectionné, on récupère ses SIs
	# ======================================================================

	# On selectionne les SIs du gène
	$select_sis_sth->execute($gene->{'gene_id'});
	my @SIs = @{$select_sis_sth->fetchall_arrayref({})};
	$select_sis_sth->finish;

	# ======================================================================
	# On analyse les entités les unes après les autres
	# ======================================================================

	# On défini une liste d'entité du gène
	my @entites_gene = ();

	# On vire les entités négatives (WTF ?)
	@infos_sondes_selectionnes = (grep { $_->{'entite_type'} > 0 } @infos_sondes_selectionnes);

	# On récupère la liste des id d'entités (et on les classe dans l'ordre)
	my @ids_entites = sort { $a <=> $b } (uniq(map { $_->{'entite_id'} } @infos_sondes_selectionnes));

	# Pour chaque exons
	foreach my $id_entite (@ids_entites){

		# On récupère les sondes de cet exon
		my @infos_sondes_exon = grep { $_->{'entite_id'} == $id_entite } @infos_sondes_selectionnes;

		# On récupère les types d'entité de l'exon (et on les classe dans l'ordre)
		my @types_entites = sort { $a <=> $b } (uniq(map { $_->{'entite_type'} } @infos_sondes_exon));

		# Pour chaque type d'entite
		foreach my $type_entite (@types_entites){

			# ======================================================
			# On selectionne les sondes de l'entité
			# ======================================================

			# On récupère les sondes de ce type d'entite
			my @infos_sondes_entite = grep {
				$_->{'entite_type'} == $type_entite
			} @infos_sondes_exon;

			# Si le type d'entité a moins de 3 sondes on zappe
			next if(@infos_sondes_entite < 3);

			# ======================================================
			# On selectionne les valeurs des sondes de l'entité
			# ======================================================

			my @sondes_entite = ();

			foreach my $infos_sonde_entite (@infos_sondes_entite){

				# On récupère les intensités
				$select_intensite_sth->execute($infos_sonde_entite->{'probe_id'});
				my $intensites = $select_intensite_sth->fetchrow_hashref;
				$select_intensite_sth->finish;

				# On récupère les valeurs de SI
				my $SIs = (grep {
					$infos_sonde_entite->{'probe_id'} == $_->{'probe_id'}
				} @SIs)[0];

				# On met les intensités et les si dans un hash,
				# que l'on ajoute a la liste
				push(@sondes_entite, {%{$intensites}, %{$SIs}});

			}

			# ======================================================
			# On calcule les valeurs d'expression de l'entité
			# ======================================================

			# On calcule l'expression de l'entité
			my %expr = expression(\@exp, \@sondes_entite);

			# ======================================================
			# On calcule le SI de l'entité (ça fait chier la c diff pour paire et impaire)
			# ======================================================

			my $si_entite;
			my @SIs_entite = ();
			my @SIs_a_tester = ();

			# => On pourra condenser quand on fera base 10 partout

			# La seule diff c'est que pour np on test avec tout les
			# si des sondes, avec p on test avec les si des paires
			# de replicats
			# Le reste pourrais être un seul algo

			# Si l'expérience est paire
			if($infos_analyse->{'type'} eq 'paire'){

				# Pour chaque paires on fait la médiane des SIs
				for(my $i = 1; $i <= @exp; $i++){

					# On récupère la médiane des SIs de ce replicat
					push(@SIs_entite, median(map {
						$_->{'SI' . $i}
					} @sondes_entite));

				}

				# Les SIs des replicats sont les SIs a tester
				@SIs_a_tester = @SIs_entite;

				# Le SI de l'entité est la médiane des SI
				# des paires (en base 10 !!)
				my @SIs_base10 = ();

				foreach(@SIs_entite){ push(@SIs_base10, 2**$_); }

				$si_entite = log2(median(@SIs_base10));

			}else{

				# Les SIs a tester sont tous les SIs de chaque sondes
				@SIs_a_tester = (map { $_->{'SI1'} } @sondes_entite);

				# Le SI de du replicat est la médiane des SIs des sondes
				push(@SIs_entite, median(@SIs_a_tester));

				# Le SI de l'entité est égal au SI du replicat
				$si_entite = $SIs_entite[0];

			}

			# On fait le test stat sur le SI de l'entité
			my $p_value = ttest($R, $si_entite, @SIs_a_tester);

			# ======================================================
			# On calcule le PSI de l'entité
			# ======================================================

			my $psi_control;
			my $psi_test;
			my $psi_sd_control;
			my $psi_sd_test;
			my $psi_fc;
			my $psi_sd_fc;
			my $p_value_psi;

			# on récupère les fcs psis de chaque paire de replicat
			my @psis_control = ();
			my @psis_test = ();
			my @psis_fcs = ();

			for(my $i = 1; $i <= @exp; $i++){

				my $psi_control = 100 * ($expr{'control' . $i} / (2**$gene->{'control' . $i}));
				my $psi_test = 100 * ($expr{'test' . $i} / (2**$gene->{'test' . $i}));

				push(@psis_control, $psi_control);
				push(@psis_test, $psi_test);
				push(@psis_fcs, $psi_test/$psi_control);

			}

			# On calcule le psi test et le psi control
			$psi_control = median(@psis_control);
			$psi_test = median(@psis_test);

			# le psi_fc de l'entité est la médiane des psis_fcs
			$psi_fc = median(@psis_fcs);

			# On calcule certains trucs seulement si l'analyse est paire
			if($infos_analyse->{'type'} eq 'paire'){

				# On calcule les standard deviation
				$psi_sd_control = sd(@psis_control);
				$psi_sd_test = sd(@psis_test);

				# le psi_sd_fc de l'entité est le sd des psis_fc
				$psi_sd_fc = sd(@psis_fcs);

				# test stat
				$p_value_psi = ttest($R, log2($psi_fc), log2(@psis_fcs));

			}

			# ======================================================
			# On calcule si l'entité est "cohérente"
			# ======================================================

			# On récupère le nombre de sondes de l'entité
			my $nb_sondes = @sondes_entite;

			# Pour chaque sonde on calcule la médiane de ses si
			# et on compte le nombre de sondes up et de sondes down
			my $nb_ups = 0;
			my $nb_downs = 0;

			foreach my $sonde_entite (@sondes_entite){

				# On calcule le si de la sonde
				my @sis_sonde = ();

				for(my $i = 1; $i <= @exp; $i++){

					push(@sis_sonde, $sonde_entite->{'SI' . $i});

				}

				my $si_sonde = median(@sis_sonde);

				# Si la sonde est up ou down on la compte
				if($si_sonde >= $const_si){ $nb_ups++; }
				if($si_sonde <= (-1 * $const_si)){ $nb_downs++; }

			}

			# On récupère la limite
			my $limit = ($nb_sondes < 5) ? 3 : int($nb_sondes*4/5);

			# On regarde si l'entité est globalement up ou down
			my $is_up = ($nb_ups >= $limit);
			my $is_down = ($nb_downs >= $limit);

			# Si l'entité est up ou down, elle est robuste
			my $is_robust = ($is_up or $is_down);

			# ======================================================
			# On ajoute l'entité à la liste des entites
			# ======================================================

			push(@entites_gene, {
				'id' => $id_entite,
				'id_gene' => $gene->{'gene_id'},
				'type' => $infos_sondes_entite[0]->{'entite_type'},
				'exon_pos' => $infos_sondes_entite[0]->{'exon_pos'},
				'nb_sondes' => $nb_sondes,
				'expression' => \%expr,
				'SIs' => \@SIs_entite,
				'SI' => $si_entite,
				'p_value' => $p_value,
				'psi_control' => $psi_control,
				'psi_test' => $psi_test,
				'psi_sd_control' => $psi_sd_control,
				'psi_sd_test' => $psi_sd_test,
				'psi_fc' => $psi_fc,
				'psi_sd_fc' => $psi_sd_fc,
				'p_value_psi' => $p_value_psi,
				'is_robust' => $is_robust
			});

		}

	}

	# ======================================================================
	# On calcule les SIs standardisés des entites du gène
	# ======================================================================

	# Pour ça il faut calculer le 'SI' du gène
	# On selectionne les entités exoniques du gène
	my @entites_exoniques = grep { $_->{'type'} == 1 } @entites_gene;

	# On récupère les médianes des SIs des entités exoniques du gène
	my @SIs_gene = ();

	# Il y en a une par paire...
	for(my $i = 1; $i <= @exp; $i++){

		my $median = (@entites_exoniques > 0)
			? median(map { @{$_->{'SIs'}}[$i - 1] } @entites_exoniques)
			: 0;

		push(@SIs_gene, $median);	

	}

	# Pour chaque entité du gène on calcule son/ses SIsd
	foreach my $entite_gene (@entites_gene){

		# On récupère les SIsd de chaque paire de replicats
		$entite_gene->{'SIsds'} = [];

		# Il y en a un par paire...
		for(my $i = 1; $i <= @exp; $i++){

			push(@{$entite_gene->{'SIsds'}}, @{$entite_gene->{'SIs'}}[$i - 1] - $SIs_gene[$i - 1]);

		}

		# Le SIsd est la médiane des SIsd des paires de replicats
		# (en cas d'analyse non paire, il y en a qu'une, prendre la
		# médiane ne change rien)
		$entite_gene->{'SIsd'} = median(@{$entite_gene->{'SIsds'}});

		# On fait un test seulement si l'analyse est paire
		if($infos_analyse->{'type'} eq 'paire'){

			$entite_gene->{'p_value_sd'} = ttest($R, $entite_gene->{'SIsd'}, @{$entite_gene->{'SIsds'}});

		}

	}

	# On ajoute les entités du gène à la liste des entités
	push(@entites, @entites_gene);

}

# ======================================================================
# On calcule les pvalues ajustées et on ajoute dans la bdd
# ======================================================================

# On corrige les pvalues des si
my @pvals_si = map { $_->{'p_value'} } @entites;
my @adjp_si = adjust_pvals(\@pvals_si);

# Si l'analyse est paire on corrige les autres pvalues
my @adjp_value_sd = ();
my @adjp_value_psi = ();

if($infos_analyse->{'type'} eq 'paire'){

	my @pvals_sd = map { $_->{'p_value_sd'} } @entites;
	my @pvals_psi = map { $_->{'p_value_psi'} } @entites;

	@adjp_value_sd = adjust_pvals(\@pvals_sd);
	@adjp_value_psi = adjust_pvals(\@pvals_psi);

}

# On ajoute chaque entité dans la bdd
for(my $i = 0; $i < @entites; $i++){

	my $entite = $entites[$i];

	my @values = ();

	push(@values, $entite->{'id'});
	push(@values, $entite->{'id_gene'});
	push(@values, $entite->{'type'});
	push(@values, $entite->{'exon_pos'});
	push(@values, (map { log2($entite->{'expression'}->{$_}) } (sort keys %{$entite->{'expression'}})));
	push(@values, (map { $_ } @{$entite->{'SIs'}})) if($paire);
	push(@values, $entite->{'SI'});
	push(@values, $entite->{'p_value'});
	push(@values, $adjp_si[$i]);
	push(@values, (map { $_ } @{$entite->{'SIsds'}})) if($paire);
	push(@values, $entite->{'SIsd'});
	push(@values, $entite->{'p_value_sd'}) if($paire);
	push(@values, $adjp_value_sd[$i]) if($paire);
	push(@values, $entite->{'psi_control'});
	push(@values, $entite->{'psi_sd_control'}) if($paire);
	push(@values, $entite->{'psi_test'});
	push(@values, $entite->{'psi_sd_test'}) if($paire);
	push(@values, $entite->{'psi_fc'});
	push(@values, $entite->{'psi_sd_fc'}) if($paire);
	push(@values, $entite->{'p_value_psi'}) if($paire);
	push(@values, $adjp_value_psi[$i]) if($paire);
	push(@values, $entite->{'nb_sondes'});
	push(@values, $entite->{'is_robust'});

	$insert_entite_sth->execute(@values);

}
