#!/usr/bin/perl
use strict;
use warnings;
use List::Util qw(sum min);

# ==============================================================================
# Formatage commun a tout les scripts
# ==============================================================================

sub get_table_sondes{

	my($organism) = @_;

	return ($organism eq 'human')
		? 'humain_probes_status'
		: 'souris_probes_status';

}

sub get_table_intensites{

	my($id_project) = @_;

	return '_' . $id_project . '_intensites';

}

sub get_table_dabg{

	my($id_project) = @_;

	return '_' . $id_project . '_dabg';

}

sub get_table_transcription{

	my($id_project, $id_analyse) = @_;

	return '_' . $id_project . '__' . $id_analyse . '_transcription';

}

sub get_table_ni{

	my($id_project, $id_analyse) = @_;

	return '_' . $id_project . '__' . $id_analyse . '_NIs';

}

sub get_table_si{

	my($id_project, $id_analyse) = @_;

	return '_' . $id_project . '__' . $id_analyse . '_SIs';

}

sub get_table_splicing{

	my($id_project, $id_analyse) = @_;

	return '_' . $id_project . '__' . $id_analyse . '_splicing';

}

# ==============================================================================
# Fonctions stats descriptive
# ==============================================================================

sub mean{

	return sum(@_)/@_
}

sub variance{

	my $mean = mean(@_);

	# Somme des écarts a la moyenne au carré
	my $sum_diffs_squared = sum(map { (($_ - $mean)**2) } @_);

	return $sum_diffs_squared/@_;
}

sub sd{

	# On calcule le coeff pour l'estimation sur la population
	my $cor = @_/(@_-1);

	# On retourne la racine carrée de la variance corrigée
	return ((variance(@_)*$cor)**0.5);

}

sub median{

	# On classe les valeurs par ordre croissant
	my @ordered = sort {$a <=> $b} @_;

	return (@_ % 2)
		? $ordered[int(@_/2)]
		: (($ordered[(@_/2) - 1] + $ordered[@_/2]) / 2);

}

sub log2{

	my($test_undef) = @_;

	return undef if !defined $test_undef;

	my @logs = ();

	foreach(@_){ push(@logs, log($_)/log(2)); }

	return (wantarray) ? @logs : $logs[0];

}

# ==============================================================================
# Description d'un expérience (retourne une liste qui va bien pour les calculs)
# ==============================================================================

sub decrire{

	my($sth, $id_analyse, $type_analyse) = @_;

	my %letter2type = ('A' => 'control', 'B' => 'test');
	my @exp = ();

	$sth->execute($id_analyse);

	while(my($letter, $condition, $num) = $sth->fetchrow_array){

		my $type = $letter2type{$letter};

		if($type_analyse eq 'paire'){

			if(!$exp[$num - 1]){

				$exp[$num - 1] = { $type => [$condition . '_' . $num] };

			}else{

				$exp[$num - 1]->{$type} = [$condition . '_' . $num];

			}

		}else{

			if(!$exp[0]){

				$exp[0] = { 'control' => [], 'test' => [] };

			}

			push(@{$exp[0]->{$type}}, $condition . '_' . $num);

		}

	}

	return @exp;

}

# ==============================================================================
# Calcul de l'expression d'une sonde a partir du dabg
# ==============================================================================

# Retourne 1 si la sonde est exprimée dans au moins la moitié des replicats
# d'au moins une condition, 0 sinon
sub dabg{

	my($seuil, $ref_exp, $sonde) = @_;

	my @exp = @{$ref_exp};
	my $nb_control = 0;
	my $nb_test = 0;
	my $nb_exp_control = 0;
	my $nb_exp_test = 0;

	foreach my $paire (@exp){

		foreach(@{$paire->{'control'}}){

			$nb_control++;

			# valeur dabg divisé par 10000 (pour avoir le float)
			my $dabg = $sonde->{$_}/10000;

			if($dabg <= $seuil){ $nb_exp_control++; }

		}

		foreach(@{$paire->{'test'}}){

			$nb_test++;

			# valeur dabg divisé par 10000 (pour avoir le float)
			my $dabg = $sonde->{$_}/10000;

			if($dabg <= $seuil){ $nb_exp_test++; }

		}

	}

	# On retourne 1 si la sonde est exprimée dans la moitié des réplicats
	# d'au moins une condition
	my $exp_control = $nb_exp_control > ($nb_control/2);
	my $exp_test = $nb_exp_test > ($nb_test/2);

	return ($exp_control or $exp_test);

}

# ==============================================================================
# Fonctions de lissage
# ==============================================================================

# Filtre une liste de sondes par un lissage de type transcription
# Cad on garde les sondes dont l'intensité est comprise dans la moyenne plus ou
# moins l'écart type des intensités de chaque réplicat d'AU MOINS une condition
sub lissage_transcription{

	my($ref_exp, $ref_sondes) = @_;

	my @exp = @{$ref_exp};
	my @sondes = @{$ref_sondes};

	# On défini la liste des sondes à utiliser pour la transcription
	my @sondes_lisses = ();

	# On récupère les samples des deux conditions
	my %conditions = ('control' => [], 'test' => []);

	foreach my $paire (@exp){

		push(@{$conditions{'control'}}, @{$paire->{'control'}});
		push(@{$conditions{'test'}}, @{$paire->{'test'}});

	}

	# Pour chaque conditions
	foreach my $condition (keys %conditions){

		# On part du principe que toutes les sondes sont gardé dans la
		# condition et on va les éliminer
		my @sondes_cond = @sondes;

		# Pour chaque replicat de la condition
		foreach my $sample (@{$conditions{$condition}}){

			# On récupère les sondes du sample
			my @sondes_rep = map { $_->{$sample} } @sondes;

			# On calcule la médiane et l'écart type
			my $mean = mean(@sondes_rep);
			my $sd = sd(@sondes_rep);

			# On garde seulement les sondes dont la valeur est comprise
			# dans la moyenne +/- l'écart type
			# Ca en élimine un certain nombre de sondes, replicat
			# après réplicat
			@sondes_cond = grep {
				abs($_->{$sample} - $mean) <= $sd
			} @sondes_cond;

		}

		# Union des listes de sondes des conditions
		# On ajoute les sondes gardés pour la condition à la liste des
		# sondes lissées en évitant les doublons
		foreach my $sonde_cond (@sondes_cond){

			# On récupère les ids des sondes déjà là
			my @probes_ids = map {$_->{'probe_id'}} @sondes_lisses;

			# Si la sonde n'est pas déjà dans la liste
			if(!($sonde_cond->{'probe_id'} ~~ @probes_ids)){

				# On l'ajoute
				push(@sondes_lisses, $sonde_cond);

			}

		}

	}

	return @sondes_lisses;

}

# Filtre une liste de sondes par un lissage de type épissage
# Cad on garde les sondes dont l'intensité est comprise dans la moyenne plus ou
# moins l'écart type des intensités de chaque réplicat DE TOUTES les conditions
# (cad de tous les réplicats)
sub lissage_epissage{

	my($ref_exp, $ref_sondes) = @_;

	my @exp = @{$ref_exp};
	my @sondes = @{$ref_sondes};

	# On défini la liste des sondes à utiliser pour l'épissage
	my @sondes_lisses = @sondes;

	# Pour chaque paires
	foreach my $p (@exp){

		foreach my $sample (@{$p->{'control'}}, @{$p->{'test'}}){

			# On récupère les sondes du réplicat
			my @sondes_rep = map {$_->{$sample}} @sondes;

			# On calcule la médiane et l'écart type
			my $mean = mean(@sondes_rep);
			my $sd = sd(@sondes_rep);

			# On garde seulement les sondes dont la valeur est comprise
			# dans la moyenne +/- l'écart type
			# Ca en élimine un certain nombre de sondes, replicat
			# après réplicat
			@sondes_lisses = grep {
				abs($_->{$sample} - $mean) <= $sd
			} @sondes_lisses;


		}

	}

	return @sondes_lisses;

}

# ==============================================================================
# Calcul de l'expression d'une liste de sonde
# ==============================================================================

# Retourne les valeurs d'expression d'un groupe de sonde
# (mediane de tout les samples d'un réplicat puis médiane de ces valeurs
# => une valeur par replicat)
sub expression{

	my($ref_exp, $ref_sondes) = @_;

	my @exp = @{$ref_exp};
	my @sondes = @{$ref_sondes};

	my @medians = ();

	for(my $i = 1; $i <= @exp; $i++){

		my $paire = $exp[$i - 1];

		my @values_controls = ();
		my @values_tests = ();

		foreach my $sonde (@sondes){

			push(@values_controls, median(map { $sonde->{$_} } @{$paire->{'control'}}));
			push(@values_tests, median(map { $sonde->{$_} } @{$paire->{'test'}}));

		}

		push(@medians, median(@values_controls));
		push(@medians, median(@values_tests));

	}

	return @medians;

}

# ==============================================================================
# Fonctions pour le fold change
# ==============================================================================

# Retourne la liste des médianes des fold changes d'un groupe de sonde
sub fcs_sondes{

	my($ref_exp, $ref_sondes) = @_;

	my @sondes = @{$ref_sondes};

	my @fcs = ();

	foreach my $sonde (@sondes){

		# On calcule la médiane des fc des replicats (dans le cas d'une
		# exp impaire, il n'y en a qu'un, donc faire la médiane change
		# rien)
		push(@fcs, median(fcs_sonde($ref_exp, $sonde)));

	}

	return @fcs;

}

# Retourne tous les fold change d'une sonde
# (=> un par paire de replicat)
sub fcs_sonde{

	my($ref_exp, $sonde) = @_;

	my @exp = @{$ref_exp};

	my @fcs_replicats = ();

	# Un compteur pour toutes les paires
	for(my $i = 1; $i <= @exp; $i++){

		# On récupère la paire courante
		my $paire = $exp[$i - 1];

		# On fait les moyenne des samples des replicats (pour les exp
		# paires ça change rien puisqu'il y a un seul sample par replicat)
		my $moyenne_control = mean(map { $sonde->{$_} } @{$paire->{'control'}});
		my $moyenne_test = mean(map { $sonde->{$_} } @{$paire->{'test'}});

		# On ajoute le fc du replicat a la liste des fc des replicats
		push(@fcs_replicats, ($moyenne_test/$moyenne_control));

	}

	return @fcs_replicats;

}

# ==============================================================================
# Fonction ttest
# ==============================================================================

# Effectue un ttest à partir d'une valeur moyenne/mediane/whatever et de la
# liste des échantillons qui a permi de calculer cette valeur
sub ttest{

	my($R, $value, @samples) = @_;

	# Si toutes les valeurs des samples sont identique, on en incrémente 1
	# de 0.01 (sinon R ne veut pas faire le test)
	if(uniq(@samples) == 1){ $samples[0]+= 0.01; }

	# On initialise les variables pour le test
	my $mu = 0;
	my $alternative = ($value > 0) ? "greater" : "less";

	# On calcule la p_value avec R
	$R->send('x <- c(' . join(', ', @samples) . ');');
	$R->send('test<-t.test(x, mu=' . $mu . ', alternative="' . $alternative . '"); print(1);');
	$R->send('print(test$p.value);');
	my $out = $R->read;
	my @outs = split(/ /, $out);
	my $p_value = $outs[1];

	return $p_value;

}

# ==============================================================================
# Fonction correction pvalues
# ==============================================================================

sub adjust_pvals{

	my ($list) = @_;

	my @list = @{$list};

	# On classe les pvalues (définies) dans l'ordre croissant
	my @list_tri = (sort {$a <=> $b} (grep { defined $_ } @list));

	# On corrige les pvaleurs
	my @list_cor = ();

	for(my $i = 0; $i < @list_tri; $i++){

		my $value_cor = (@list_tri / ($i + 1)) * $list_tri[$i];

		push(@list_cor, $value_cor);

	}

	# On les "classe" "en escalier" :)
	my @list_cor_ord = ();

	for(my $i = 0; $i < @list_cor; $i++){

		my $min = min($list_cor[$i], @list_cor[($i + 1)..$#list_tri]);

		push(@list_cor_ord, $min);

	}

	# On associe les valeurs de pvalue aux valeurs de pvalue corrigée
	my %h_pval_pvalcor = ();

	for(my $i = 0; $i < @list_tri; $i++){

		$h_pval_pvalcor{$list_tri[$i]} = $list_cor_ord[$i];

	}

	# On refait une liste avec les valeurs corrigées, dans le bon ordre
	my @list_cor_ordre_origine = ();

	foreach my $val (@list){

		my $val_cor = (defined $val) ? $h_pval_pvalcor{$val} : undef;

		push(@list_cor_ordre_origine, $val_cor);

	}

	# On retourne la liste dans le bon ordre
	return @list_cor_ordre_origine;

}

1;
