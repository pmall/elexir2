#!/usr/bin/perl
use strict;
use warnings;
use DBI;
use List::MoreUtils qw(uniq);
use Statistics::R;
use FindBin qw($Bin);
use lib $FindBin::Bin . '/../lib';
use Format;
use Math;
use Analyse;
use Stats;

# ==============================================================================
# Parametres
# ==============================================================================

# On récupère l'id du projet a analyser
my $id_analyse = shift @ARGV || die('Vous devez passer l\'id d\'une analyse en paramètre');
my $limit = shift @ARGV // 18446744073709551615; # Si pas indiqué, on met maxint /

# Seuil pour le dabg
my $seuil_dabg = 0.05;

# On défini les identifiants pour la bdd
my $db_host = 'localhost';
my $db_name = 'elexir2';
my $db_user = 'elexir2';
my $db_pass = 'pandas';

# On ouvre une session R pour le script
my $R = Statistics::R->new();
$R->startR;

# ==============================================================================
# On prépare les requetes
# ==============================================================================

# On se connecte a elexir
my $dbh = DBI->connect(
	'DBI:mysql:' . $db_name . ':' . $db_host,
	$db_user,
	$db_pass
);

# On selectionne les infos de l'analyse
my $select_infos_analyse_sth = $dbh->prepare(
	"SELECT p.id AS id_project, p.type AS type_chips, p.organism, a.type
	FROM analyses AS a, projects AS p
	WHERE a.id_project = p.id
	AND a.id = ?"
);

# On selectionne les conditions du projet
my $select_chips_sth = $dbh->prepare(
	"SELECT g.letter, c.condition, c.num
	FROM groups AS g, chips AS c
	WHERE g.condition = c.condition
	AND g.id_analysis = ?"
);

# On selectionne les gènes
my $select_genes_sth = $dbh->prepare(
	"SELECT DISTINCT(gene_id) FROM humain_probes_status LIMIT ?"
);

# ==============================================================================
# On teste si l'analyse existe bien
# ==============================================================================

$select_infos_analyse_sth->execute($id_analyse);

my $infos_analyse = $select_infos_analyse_sth->fetchrow_hashref;

die('L\'id de l\'analyse n\'est pas valide.') if(!$infos_analyse);

# ==============================================================================
# On crée les noms de table dont on a besoin
# ==============================================================================

my $table_sondes = get_table_sondes($infos_analyse->{'organism'});
my $table_intensites = get_table_intensites($infos_analyse->{'id_project'});
my $table_dabg = get_table_dabg($infos_analyse->{'id_project'});
my $table_trans = get_table_transcription($infos_analyse->{'id_project'}, $id_analyse);

# ==============================================================================
# On prépare la requete pour les sondes avec ces infos
# ==============================================================================

# On selectionne les sondes d'un gène
my $select_infos_sondes_sth = $dbh->prepare(
	"SELECT probe_id, exon_pos
	FROM " . $table_sondes . "
	WHERE entite_type = 1
	AND gc_content < 18
	AND nb_occ = 1
	AND gene_id = ?"
);

# On selectionne le dabg d'une sonde
my $select_dabg_sth = $dbh->prepare(
	"SELECT * FROM " . $table_dabg . " WHERE probe_id = ?"
);

# On selectionne l'intensité d'une sonde
my $select_intensite_sth = $dbh->prepare(
	"SELECT * FROM " . $table_intensites . " WHERE probe_id = ?"
);

# ==============================================================================
# On récupère la description de l'expérience
# ==============================================================================

my @exp = decrire(
	$select_chips_sth,
	$id_analyse,
	$infos_analyse->{'type'}
);

# ==============================================================================
# On crée la table qui contient les valeurs des gène
# ==============================================================================

my @fields_expr = ();

for(my $i = 1; $i <= @exp; $i++){

	push(@fields_expr, 'control' . $i);
	push(@fields_expr, 'test' . $i);

}

my @fields_trans = (
	'gene_id INT UNSIGNED NOT NULL PRIMARY KEY',
	(map { $_ . ' DECIMAL(10,5) UNSIGNED NOT NULL'; } @fields_expr),
	'trans_fc DECIMAL(10,5) NOT NULL',
	'trans_pval DECIMAL(12,10) UNSIGNED NOT NULL',
	'trans_adjp DECIMAL(12,10) UNSIGNED NOT NULL',
	'trans_nb_sondes SMALLINT UNSIGNED NOT NULL',
	'trans_nb_exons SMALLINT UNSIGNED NOT NULL',
	'epi_fc DECIMAL(10,5)',
	'epi_pval DECIMAL(12,5) UNSIGNED',
	'epi_adjp DECIMAL(12,5) UNSIGNED',
	'epi_nb_sondes SMALLINT UNSIGNED',
	'epi_nb_exons SMALLINT UNSIGNED',
	'a_utiliser_pour_splicing TINYINT UNSIGNED'
);

$dbh->do('DROP TABLE IF EXISTS ' . $table_trans);
$dbh->do('CREATE TABLE ' . $table_trans . ' (' . join(', ', @fields_trans) . ')');

my $insert_gene_sth = $dbh->prepare(
	"INSERT INTO $table_trans VALUES(" . join(', ', ('?')x@fields_trans) . ")"
);

# ==============================================================================
# On début l'algo, pour chaque gène
# ==============================================================================

my $i = 0;

# On défini une liste de gènes (on les garde tous dans une liste pour calculer
# les pvals ajustés)
my @genes = ();

# On selectionne les gènes
$select_genes_sth->execute($limit);

# Pour chaque gène
while(my($id_gene) = $select_genes_sth->fetchrow_array){

	print '' . (++$i) . "\n";

	# ======================================================================
	# On récupère les intensités des sondes du gène
	# ======================================================================

	# On récupère les infos des sondes
	$select_infos_sondes_sth->execute($id_gene);
	my $infos_sondes = $select_infos_sondes_sth->fetchall_hashref('probe_id');
	$select_infos_sondes_sth->finish;

	# On récupère les valeurs de dabg de chaque sonde
	my @dabg =();

	foreach my $probe_id (keys %{$infos_sondes}){

		$select_dabg_sth->execute($probe_id);
		my $values = $select_dabg_sth->fetchrow_hashref;
		$select_dabg_sth->finish;

		push(@dabg, $values);

	}

	# On ne garde que les sondes qui sont exprimés dans cette analyse
	my @sondes_exprimes = grep { dabg($seuil_dabg, \@exp, $_) } @dabg;

	# Si il n'y a pas six sondes exprimées on zappe
	next if(@sondes_exprimes < 6);

	# On récupère les intensites des sondes exprimés
	my @sondes = ();

	foreach my $sonde_exprime (@sondes_exprimes){

		$select_intensite_sth->execute($sonde_exprime->{'probe_id'});
		my $sonde = $select_intensite_sth->fetchrow_hashref;
		$select_intensite_sth->finish;

		push(@sondes, $sonde);

	}

	# ======================================================================
	# Calcul de l'expression de gène
	# ======================================================================

	my @expr = expression(\@exp, \@sondes);

	# ======================================================================
	# Etape de lissage pour la transcription
	# ======================================================================

	# On selectionne les sondes qui passe le lissage transcription
	my @sondes_trans = lissage_transcription(\@exp, \@sondes);

	# Si il n'y a pas six sondes ça sert a rien de continuer pour ce gène
	next if(@sondes_trans < 6);

	# ======================================================================
	# Calcul des fold change et de la pvalue pour la transcription
	# ======================================================================

	# On calcul les fold change des sondes
	my @fcs_trans = fcs_sondes(\@exp, \@sondes_trans);

	# le fc du gène est la médiane des fc des sondes
	my $fc_gene_trans = median(@fcs_trans);

	# On calcule la p value pour la transcription
	my $p_value_trans = ttest($R, log2($fc_gene_trans), log2(@fcs_trans));

	# ======================================================================
	# Etape de lissage pour l'épissage
	# ======================================================================

	# On selectionne les sondes qui passe le lissage de l'épissage
	my @sondes_epissage = lissage_epissage(\@exp, \@sondes);

	my $fc_gene_epissage;
	my $p_value_epissage;

	# Seulement si on a plus de 6 sondes épissage
	if(@sondes_epissage >= 6){

		# ==============================================================
		# Calcul des fold change et de la pvalue pour l'épissage
		# ==============================================================

		# On calcul les fold change des sondes epissage selon si l'analyse
		# est paire ou non
		my @fcs_epissage = fcs_sondes(\@exp, \@sondes_epissage);

		# le fc du gène est la médiane des fc des sondes
		$fc_gene_epissage = median(@fcs_epissage);

		# On calcule la p value pour l'épissage
		$p_value_epissage = ttest($R, log2($fc_gene_epissage), log2(@fcs_epissage));

	}

	# ======================================================================
	# On ajoute les valeurs à la liste de gène
	# ======================================================================

	push(@genes, {
		'id' => $id_gene,
		'expression' => \@expr,
		'fc_trans' => $fc_gene_trans,
		'p_value_trans' => $p_value_trans,
		'nb_sondes_trans' => scalar(@sondes_trans),
		'nb_exons_trans' => scalar(uniq(map { $infos_sondes->{$_->{'probe_id'}}->{exon_pos} } @sondes_trans)),
		'fc_epi' => $fc_gene_epissage,
		'p_value_epi' => $p_value_epissage,
		'nb_sondes_epi' => scalar(@sondes_epissage),
		'nb_exons_epi' => scalar(uniq(map { $infos_sondes->{$_->{'probe_id'}}->{exon_pos} } @sondes_epissage)),
		'a_utiliser_pour_splicing' => (defined $fc_gene_epissage)
	});

}

# ==============================================================================
# On calcule les p values ajustées
# ==============================================================================

# On récupère la totalité des listes de pvalues trans et epi
my @pvals_trans = map { $_->{'p_value_trans'} } @genes;
my @pvals_epi = map { $_->{'p_value_epi'} } @genes;

# On les corrige
my @adjp_trans = adjust_pvals(\@pvals_trans);
my @adjp_epi = adjust_pvals(\@pvals_epi);

# Pour chaque gène
for(my $i = 0; $i < @genes; $i++){

	# On récupère le gènes
	my $gene = $genes[$i];

	# On insert le gène dans la bdd
	$insert_gene_sth->execute(
		$gene->{'id'},
		(map { log2($_) } (@{$gene->{'expression'}})),
		log2($gene->{'fc_trans'}),
		$gene->{'p_value_trans'},
		$adjp_trans[$i],
		$gene->{'nb_sondes_trans'},
		$gene->{'nb_exons_trans'},
		log2($gene->{'fc_epi'}),
		$gene->{'p_value_epi'},
		$adjp_epi[$i],
		$gene->{'nb_sondes_epi'},
		$gene->{'nb_exons_epi'},
		$gene->{'a_utiliser_pour_splicing'}
	);

}
