#!/usr/bin/perl
use strict;
use warnings;
use YAML::XS qw(LoadFile);
use DBI;
use List::MoreUtils qw(uniq);
use FindBin qw($Bin);
use lib $FindBin::Bin . '/../lib';
use Format;
use Math;
use Analyse;
use Stats;

# ==============================================================================
# Parametres
# ==============================================================================

# On récupère l'id du projet a analyser
my $id_analyse = shift @ARGV || die('Vous devez passer l\'id d\'une analyse en paramètre');
my $limit = shift @ARGV // 18446744073709551615; # Si pas indiqué, on met maxint /

# On récupère un hash de config
my $config = LoadFile($FindBin::Bin . '/../config.yml');

# On défini les identifiants pour la bdd
my $db_host = $config->{'db_host'};
my $db_user = $config->{'db_user'};
my $db_pass = $config->{'db_pass'};
my $db_name = $config->{'db_name'};

# Parametres pour l'analyse
my $gc_max = $config->{'simple'}{'gc_max'};
my $nb_occ_max = $config->{'simple'}{'nb_occ_max'};
my $seuil_dabg = $config->{'simple'}{'seuil_dabg'};
my $nb_sondes_min_gene = $config->{'simple'}{'nb_sondes_min_gene'};
my $nb_exon_min_homogene = $config->{'simple'}{'nb_exons_min_homogene'};
my $nb_min_par_exon_homogene = $config->{'simple'}{'nb_min_par_exon_homogene'}; 

# ==============================================================================
# On récupère les infos de l'exp
# ==============================================================================

# On se connecte a elexir
my $dbh = DBI->connect(
	'DBI:mysql:' . $db_name . ':' . $db_host,
	$db_user,
	$db_pass
);

# On récupère les infos de l'analyse
my $infos_analyse = get_infos_analyse($dbh, $id_analyse);

# Message d'erreur si l'analyse n'existe pas
die('L\'id de l\'analyse n\'est pas valide.') if(!$infos_analyse);

# Message d'erreur si c'est pas le bon script pour le bon type d'analyse
if($infos_analyse->{'type'} ne 'simple'){

	die('Le script simple ne fonctionne que sur les analyses simples :o)');

}

# ==============================================================================
# On crée les noms de table dont on a besoin
# ==============================================================================

my $base_fasterdb = $config->{'db_name_fasterdb'}{$infos_analyse->{'version'}}{$infos_analyse->{'organism'}};
my $table_genes = $config->{'table_genes'}{$infos_analyse->{'version'}};
my $table_exons = $config->{'table_exons'}{$infos_analyse->{'version'}};
my $table_sondes = $config->{'table_sondes'}{$infos_analyse->{'type_chips'}}{$infos_analyse->{'version'}}{$infos_analyse->{'organism'}};
my $table_dabg = get_table_dabg($infos_analyse->{'id_project'});
my $table_intensites = get_table_intensites($infos_analyse->{'id_project'});
my $table_trans = get_table_transcription($infos_analyse->{'id_project'}, $id_analyse);

# ==============================================================================
# On prépare les requetes sur la bonne base fasterdb
# ==============================================================================

# On se connecte a fasterdb
my $dbh_fdb = DBI->connect(
	'DBI:mysql:' . $base_fasterdb . ':' . $db_host,
	$db_user,
	$db_pass
);

# On selectionne les gènes
my $select_genes_sth = $dbh_fdb->prepare("SELECT id FROM $table_genes LIMIT ?");

# On selectionne le nombre d'exons d'un gène
my $select_nb_exons_gene_sth = $dbh_fdb->prepare(
	"SELECT COUNT(id) AS nb_exons FROM $table_exons WHERE id_gene = ?"
);

# ==============================================================================
# On prépare la requete pour les sondes avec ces infos
# ==============================================================================

# On selectionne les sondes d'un gène
my $select_infos_sondes_sth = $dbh->prepare(
	"SELECT probe_id, nb_occ, gc_content, exon_pos
	FROM " . $table_sondes . "
	WHERE entite_type = 1
	AND utiliser_dans_analyse = 1
	AND gene_id = ?"
);

# On selectionne le dabg d'une sonde
my $select_dabg_sth = $dbh->prepare(
	"SELECT * FROM " . $table_dabg . " WHERE probe_id = ?"
);

# On selectionne l'intensité d'une sonde
my $select_intensite_sth = $dbh->prepare(
	"SELECT * FROM " . $table_intensites . " WHERE probe_id = ?"
);

# ==============================================================================
# On crée la table qui contient les valeurs des gène
# ==============================================================================

my @fields_expr = ();

for(my $i = 1; $i <= @{$infos_analyse->{'design'}}; $i++){

	push(@fields_expr, 'control' . $i);
	push(@fields_expr, 'test' . $i);

}

my @fields_trans = (
	'gene_id INT UNSIGNED NOT NULL PRIMARY KEY',
	(map { $_ . ' DECIMAL(10,5) UNSIGNED NOT NULL'; } @fields_expr),
	'trans_fc DECIMAL(10,5) UNSIGNED NOT NULL',
	'trans_pval DECIMAL(12,10) UNSIGNED NOT NULL',
	'trans_adjp DECIMAL(12,10) UNSIGNED NOT NULL',
	'trans_nb_sondes SMALLINT UNSIGNED NOT NULL',
	'trans_nb_exons SMALLINT UNSIGNED NOT NULL',
	'epi_fc DECIMAL(10,5) UNSIGNED',
	'epi_pval DECIMAL(12,5) UNSIGNED',
	'epi_adjp DECIMAL(12,5) UNSIGNED',
	'epi_nb_sondes SMALLINT UNSIGNED',
	'epi_nb_exons SMALLINT UNSIGNED'
);

$dbh->do('DROP TABLE IF EXISTS ' . $table_trans);
$dbh->do('CREATE TABLE ' . $table_trans . ' (' . join(', ', @fields_trans) . ')');

my $insert_gene_sth = $dbh->prepare(
	"INSERT INTO $table_trans VALUES(" . join(', ', ('?')x@fields_trans) . ")"
);

# ==============================================================================
# On début l'algo, pour chaque gène
# ==============================================================================

print 'Analyse des gènes' . "\n";

# On défini une liste de gènes (on les garde tous dans une liste pour calculer
# les pvals ajustés)
my @genes = ();

# On selectionne les gènes
$select_genes_sth->execute($limit);

# Pour chaque gène
while(my($id_gene) = $select_genes_sth->fetchrow_array){

	print $id_gene . "\n";

	# ======================================================================
	# On récupère les intensités des sondes du gène
	# ======================================================================

	# On récupère les infos des sondes
	$select_infos_sondes_sth->execute($id_gene);
	my $infos_sondes = $select_infos_sondes_sth->fetchall_hashref('probe_id');
	$select_infos_sondes_sth->finish;

	# Si le gène a moins de six sondes on zappe ça sert a rien
	next if(scalar(keys %{$infos_sondes}) < $nb_sondes_min_gene);

	# On vire les sondes qui ont pas les bonnes caractéristiques
	my $ids_probes_ok = [grep {
		# ON VIRE LES SONDES AVEC UN GC <= 2 PARCE QU'ON A PAS PU
		# CALCULER LEUR DABG AVEC APT :((
		$infos_sondes->{$_}->{'gc_content'} > 2
		and
		$infos_sondes->{$_}->{'nb_occ'} <= $nb_occ_max
		and
		$infos_sondes->{$_}->{'gc_content'} <= $gc_max
	} keys %{$infos_sondes}];

	# Si le gène a moins de six sondes avec de bon critères on zappe
	next if(@{$ids_probes_ok} < $nb_sondes_min_gene);

	# On récupère les valeurs de dabg de chaque sonde
	my @sondes = ();

	# Pour chaque id de sonde
	foreach my $probe_id (@{$ids_probes_ok}){

		# On récupère les valeurs de dabg de la sonde
		$select_dabg_sth->execute($probe_id);
		my $dabg = $select_dabg_sth->fetchrow_hashref;
		$select_dabg_sth->finish;

		# Si la sonde est exprimée
		if(dabg($infos_analyse->{'design'}, $dabg, $seuil_dabg)){

			# On va chercher ses intensites
			$select_intensite_sth->execute($probe_id);
			my $sonde = $select_intensite_sth->fetchrow_hashref;
			$select_intensite_sth->finish;

			# Et on l'ajoute à la liste des sondes
			push(@sondes, $sonde);

		}

	}

	# Si il n'y a pas six sondes on zappe
	next if(@sondes < $nb_sondes_min_gene);

	# ======================================================================
	# Calcul de l'expression de gène
	# ======================================================================

	my @expr = expressions($infos_analyse->{'design'}, \@sondes);

	# ======================================================================
	# Etape de lissage pour la transcription
	# ======================================================================

	# On selectionne les sondes qui passe le lissage transcription
	my @sondes_trans = lissage_transcription($infos_analyse->{'design'}, \@sondes);

	# Si il n'y a pas six sondes ça sert a rien de continuer pour ce gène
	next if(@sondes_trans < $nb_sondes_min_gene);

	# ======================================================================
	# Calcul des fold change et de la pvalue pour la transcription
	# ======================================================================

	# Calcul du fc du gène et de sa p_value
	my($fc_gene_trans, $p_value_trans) = fc_gene(
		$infos_analyse->{'design'},
		\@sondes_trans
	);

	# NB sondes utilisées pour la transcription
	my $nb_sondes_trans = @sondes_trans;

	# NB exons cibles par des sondes lors de la transcription
	my $nb_exons_trans = scalar(uniq(map {
		$infos_sondes->{$_->{'probe_id'}}->{'exon_pos'}
	} @sondes_trans));

	# ======================================================================
	# Analyse au niveau de l'épissage
	# ======================================================================

	# On déclare les valeurs d'épissage
	my @sondes_epissage = ();
	my $fc_gene_epissage;
	my $p_value_epissage;
	my $nb_sondes_epissage;
	my $nb_exons_epissage;

	# ======================================================================
	# On fait l'épissage seulement si le gène est homogène
	# ======================================================================

	# On selectionne son nombre d'exon du gène
	$select_nb_exons_gene_sth->execute($id_gene);
	my($nb_exons) = $select_nb_exons_gene_sth->fetchrow_array;
	$select_nb_exons_gene_sth->finish;

	# Si le gène est homogène on calcule les valeurs d'épissage
	my $homogene = homogene(
		$infos_sondes,
		\@sondes,
		$nb_exons,
		$nb_exon_min_homogene,
		$nb_min_par_exon_homogene
	);

	if($homogene){

		# ==============================================================
		# Etape de lissage pour l'épissage
		# ==============================================================

		# On selectionne les sondes qui passe le lissage de l'épissage
		@sondes_epissage = lissage_epissage($infos_analyse->{'design'}, \@sondes);

		# Seulement si on a plus de 6 sondes épissage
		if(@sondes_epissage >= $nb_sondes_min_gene){

			# ======================================================
			# Calcul des fold change et de la pvalue pour l'épissage
			# ======================================================

			# Calcul du fc du gène et de sa p_value
			($fc_gene_epissage, $p_value_epissage) = fc_gene(
				$infos_analyse->{'design'},
				\@sondes_epissage
			);

			# NB sondes utilisées pour l'épissage
			$nb_sondes_epissage = @sondes_epissage;

			# NB exons cibles par des sondes lors de l'épissage
			$nb_exons_epissage = scalar(uniq(map {
				$infos_sondes->{$_->{'probe_id'}}->{'exon_pos'}
			} @sondes_epissage));

		}

	}

	# ======================================================================
	# On ajoute les valeurs à la liste de gène
	# ======================================================================

	# On ajoute le gène à la liste
	push(@genes, {
		'id' => $id_gene,
		'expression' => \@expr,
		'fc_trans' => $fc_gene_trans,
		'p_value_trans' => $p_value_trans,
		'nb_sondes_trans' => $nb_sondes_trans,
		'nb_exons_trans' => $nb_exons_trans,
		'fc_epi' => $fc_gene_epissage,
		'p_value_epi' => $p_value_epissage,
		'nb_sondes_epi' => $nb_sondes_epissage,
		'nb_exons_epi' => $nb_exons_epissage
	});

}

# ==============================================================================
# On calcule les p values ajustées
# ==============================================================================

# On les corrige
my @adjp_trans = adjust_pvals(map { $_->{'p_value_trans'} } @genes);
my @adjp_epi = adjust_pvals(map { $_->{'p_value_epi'} } @genes);

# Pour chaque gène
for(my $i = 0; $i < @genes; $i++){

	# On récupère le gènes
	my $gene = $genes[$i];

	# On insert le gène dans la bdd
	$insert_gene_sth->execute(
		$gene->{'id'},
		(map { $_ } (@{$gene->{'expression'}})),
		$gene->{'fc_trans'},
		$gene->{'p_value_trans'},
		$adjp_trans[$i],
		$gene->{'nb_sondes_trans'},
		$gene->{'nb_exons_trans'},
		$gene->{'fc_epi'},
		$gene->{'p_value_epi'},
		$adjp_epi[$i],
		$gene->{'nb_sondes_epi'},
		$gene->{'nb_exons_epi'}
	);

}
