#!/usr/bin/perl
use warnings;
use strict;
use YAML::XS qw(LoadFile);
use DBI;
use File::Path qw(make_path);
use Spreadsheet::WriteExcel;
use FindBin qw($Bin);
use lib "$FindBin::Bin/../lib";
use Format;
use Math;
use Analyse;

# ==============================================================================
# Parametres
# ==============================================================================

# On récupère l'id du projet a analyser
my $id_analyse = shift @ARGV || die('Vous devez passer l\'id d\'une analyse en paramètre');

# On récupère un hash de config
my $config = LoadFile($FindBin::Bin . '/../config.yml');

# On défini les identifiants pour la bdd
my $db_host = $config->{'db_host'};
my $db_user = $config->{'db_user'};
my $db_pass = $config->{'db_pass'};
my $db_name = $config->{'db_name'};

# Paramètres de sélection pour les résulats
my $seuil_epissage = $config->{'simple'}{'excel'}{'seuil_epissage'};
my $seuil_pval = $config->{'simple'}{'excel'}{'seuil_pval'};
my $seuil_fiabilite_fcGene = $config->{'simple'}{'excel'}{'seuil_fc_gene'};

# Répertoire de sortie 
my $dir_xls = $config->{'dir_xls'};

# ==============================================================================
# On récupère les infos de l'analyse
# ==============================================================================

my $dbh = DBI->connect(
	"DBI:mysql:" . $db_name . ":" . $db_host,
	$db_user,
	$db_pass
);

my $analyse = Analyse->get_analyse($dbh, $id_analyse);

die('L\'id de l\'analyse n\'est pas valide.') if(!$analyse);

# Message d'erreur si c'est pas le bon script pour le bon type d'analyse
if($analyse->{'type'} ne 'simple'){

	die('Le script simple ne fonctionne que sur les analyses simples :o)');

}

# ==============================================================================
# On récupère les infos dont on a besoin selon les infos de l'analyse
# ==============================================================================

# On récupère les infos de la bdd
my $id_projet = $analyse->{"id_project"};
my $type_chips = $analyse->{'type_chips'};
my $version = $analyse->{'version'};
my $orga = $analyse->{'organism'};
my $name = $analyse->{'name'};
my $paire = $analyse->{'paired'};

# on crée les variables du script qui déendent de l'analyse
my $table_genes = $config->{'table_genes'}{$version}{$orga};
my $table_entites = $config->{'table_entites'}{$version}{$orga};
my $table_trans = get_table_transcription($id_projet, $id_analyse);
my $table_splicing = get_table_splicing($id_projet, $id_analyse);
my $dir_sortie = $dir_xls . '/' . $id_projet . '/' . $id_analyse;
my $fichier_sortie = $dir_sortie . '/' . $name . '_epissage_psi.xls';

# On crée les dossier
make_path($dir_sortie);

# ==============================================================================
# On se connecte a fasterdb
# ==============================================================================

my $select_entites_nofdr_sth = $dbh->prepare(
	"SELECT e.*, g.epi_fc, g.epi_pval, g.epi_nb_sondes, g.epi_nb_exons
	FROM $table_trans AS g, $table_splicing AS e
	WHERE g.id_gene = e.id_gene
	AND ABS(LOG2(psi_fc)) >= LOG2(?)
	AND psi_pval <= ?
	AND is_robust = 1"
);

my $select_entites_fdr_sth = $dbh->prepare(
	"SELECT e.*, g.epi_fc, g.epi_pval, g.epi_nb_sondes, g.epi_nb_exons,
	e.psi_adjp AS psi_pval
	FROM $table_trans AS g, $table_splicing AS e
	WHERE g.id_gene = e.id_gene
	AND ABS(LOG2(psi_fc)) >= LOG2(?)
	AND psi_adjp <= ?
	AND is_robust = 1"
);

my $select_infos_gene_sth = $dbh->prepare(
	"SELECT * FROM $table_genes WHERE id_fasterdb = ?"
);

my $select_infos_entite_sth = $dbh->prepare(
	"SELECT id, type, exon_pos, start_sur_gene, end_sur_gene
	FROM $table_entites
	WHERE id = ?"
);

# ==============================================================================
# Initialisation fichier excel
# ==============================================================================

# Fichier
my $xlsh			= Spreadsheet::WriteExcel->new($fichier_sortie);

# Feuilles
my $f_resume			= $xlsh->add_worksheet('Parametres et entites analysees');
my $f_epissage_no_fdr		= $xlsh->add_worksheet('NO FDR');
my $f_epissage_fdr		= $xlsh->add_worksheet('FDR');

# Couleurs
my $couleur_entete		= $xlsh->set_custom_color(39, 189, 189, 189);

# Formats
my $format_resume_titre		= $xlsh->add_format(color => 'black', bold => 1, center_across => 1);
my $format_resume_intermediaire	= $xlsh->add_format(color => 'black', italic => 1, center_across => 1);
my $format_resume_cell		= $xlsh->add_format(color => 'black', bold => 0, center_across => 1);
my $format_merge_entete		= $xlsh->add_format(color => 'black', bold => 1, bg_color => $couleur_entete, border => 2, border_color => 'black', center_across => 1);
my $format_entete		= $xlsh->add_format(color => 'black', bold => 1, bg_color => $couleur_entete, border => 2, border_color => 'black', center_across => 1);
my $format_cell			= $xlsh->add_format(color => 'black', border => 1, border_color => 'black', center_across => 1);
my $format_cell_mauv_fc		= $xlsh->add_format(color => 'red', border => 1, border_color => 'black', center_across => 1);
my $format_cell_no_center	= $xlsh->add_format(color => 'black', bold => 0);

# ==============================================================================
# Feuille résumé
# ==============================================================================

# Infos de base
$f_resume->write(0, 0, date(), $format_cell_no_center);
$f_resume->write(2, 0, "Parametres utilises", $format_resume_titre);
$f_resume->write(3, 0, "Seuil fold", $format_resume_titre);
$f_resume->write(3, 1, round($seuil_epissage, 2), $format_resume_titre);
$f_resume->write(4, 0, "Seuil p-value", $format_resume_titre);
$f_resume->write(4, 1, $seuil_pval, $format_resume_titre);

# ==============================================================================
# On ajoute les entités dans les feuilles
# ==============================================================================

my @entites = ();

# On selectionne les entites no fdr
$select_entites_nofdr_sth->execute($seuil_epissage, $seuil_pval);
@entites = @{$select_entites_nofdr_sth->fetchall_arrayref({})};
$select_entites_nofdr_sth->finish;

my($nb_nofdr_up, $nb_nofdr_down) = write_list($f_epissage_no_fdr, @entites);

# On selectionne les entites fdr
$select_entites_fdr_sth->execute($seuil_epissage, $seuil_pval);
@entites = @{$select_entites_fdr_sth->fetchall_arrayref({})};
$select_entites_fdr_sth->finish;

my($nb_fdr_up, $nb_fdr_down) = write_list($f_epissage_fdr, @entites);

# ==============================================================================
# Fonction pour remplir la feuille
# ==============================================================================

sub write_list{

	my($f, @entites) = @_;

	my $nb_gene = 0;
	my $gene_id_prec = 0;
	my $nb_ups = 0;
	my $nb_downs = 0;

	# On défini les entete groupées
	$f->merge_range(0, 1, 0, 8, 'Infos gene', $format_merge_entete);
	$f->merge_range(0, 9, 0, 12, 'Infos entite', $format_merge_entete);
	$f->merge_range(0, 13, 0, 15, 'Reg gene', $format_merge_entete);
	$f->merge_range(0, 16, 0, 18, 'Reg psi', $format_merge_entete);
	$f->merge_range(0, 19, 0, 20, 'Other algorithms', $format_merge_entete);

	# On défini les entetes de chaque colonnes
	my @entetes = (
		'Gene',
		# Infos du gène
		'Fasterdb id',
		'Source id',
		'Link Elexir',
		'Symbol',
		'Description',
		'Chr Position',
		'Nb probes',
		'Nb exons',
		# Infos entité
		'Elexir id',
		'AS Event Type',
		'Exon position',
		'Nb probes',
		'AS Event Sequence',
		# Reg gène
		'Regulation',
		'FC',
		'Pvalue',
		# Reg psi
		'Regulation',
		'Med psi fc',
		'Pvalue',
		# Autres algos
		'SI',
		'SIsd'
	);

	for(my $j = 0; $j < @entetes; $j++){

		$f->write(1, $j, $entetes[$j], $format_entete);

	}

	# Fonction qui retourne 1 si l'entité est valide pour les trois types
	sub commun{

		my($entite) = @_;

		return(
			((format_fold($entite->{'SI'}) >= $seuil_epissage) and ($entite->{'SI_pval'} <= $seuil_pval))
			and
			((format_fold($entite->{'SIsd'}) >= $seuil_epissage) and ($entite->{'SIsd_pval'} <= $seuil_pval))
		);

	}

	# On classe les entites
	@entites = sort {
		# On classe déjà les communs en premier
		commun($b) <=> commun($a)
		||
		# Ensuite par FC gène fiable
		(format_fold($b->{'epi_fc'}) <= $seuil_fiabilite_fcGene)
		<=>
		(format_fold($a->{'epi_fc'}) <= $seuil_fiabilite_fcGene)
		||
		# Ensuite par gène
		$a->{'id_gene'} <=> $b->{'id_gene'}
	} @entites;

	my $nb_lignes = 2;

	# Pour chaque entité
	for(my $i = 0; $i < @entites; $i++){

		my $entite = $entites[$i];

		# On récupère les infos du gène
		$select_infos_gene_sth->execute($entite->{'id_gene'});
		my $infos_gene = $select_infos_gene_sth->fetchrow_hashref;
		$select_infos_gene_sth->finish;

		# On récupère les infos de l'entité
		$select_infos_entite_sth->execute($entite->{'id_entite'});
		my $infos_entite = $select_infos_entite_sth->fetchrow_hashref;
		$select_infos_entite_sth->finish;

		# On met a jour le numéro du gène
		if($infos_gene->{'id_fasterdb'} != $gene_id_prec){

			$nb_gene++;

			$gene_id_prec = $infos_gene->{'id_fasterdb'};

		}

		# On compte les up et les down
		($entite->{'psi_fc'} >= 1) ? $nb_ups++ : $nb_downs++;

		my $pos_chrom =
			$infos_gene->{'chromosome'} .
			':' . $infos_gene->{'start_sur_chromosome'} .
			'-' . $infos_gene->{'end_sur_chromosome'} .
			':' . $infos_gene->{'strand'};

		my $prefix_pos = ($infos_entite->{'type'} eq 'intron-retention')
			? 'i' : 'e' ;

		my $pos_entite =
			$prefix_pos . $entite->{'exon_pos'} .
			':' . $infos_entite->{'start_sur_gene'} .
			'-' . $infos_entite->{'end_sur_gene'};

		my $reg_gene = ($entite->{'epi_fc'} >= 1) ? 'up' : 'down';
		my $reg_psi = ($entite->{'psi_fc'} >= 1) ? 'up' : 'down';

		my $format = (format_fold($entite->{'epi_fc'}) <= $seuil_fiabilite_fcGene)
			? $format_cell
			: $format_cell_mauv_fc;

		my $SI_ok = ((format_fold($entite->{'SI'}) >= $seuil_epissage) and ($entite->{'SI_pval'} <= $seuil_pval));
		my $SIsd_ok = ((format_fold($entite->{'SIsd'}) >= $seuil_epissage) and ($entite->{'SIsd_pval'} <= $seuil_pval));

		# On crée le tableau de data
		my @data = (
			$nb_gene,
			# Infos du gène
			$infos_gene->{'id_fasterdb'},
			$infos_gene->{'id_source'},
			'blah',
			$infos_gene->{'symbol'},
			$infos_gene->{'description'},
			$pos_chrom,
			$entite->{'epi_nb_sondes'},
			$entite->{'epi_nb_exons'},
			# Infos entité
			$infos_entite->{'type'},
			$pos_entite,
			$entite->{'nb_sondes'},
			'seq',
			# Regulation gène
			$reg_gene,
			format_fold($entite->{'epi_fc'}),
			$entite->{'epi_pval'},
			# Algo psi
			$reg_psi,
			format_fold($entite->{'psi_fc'}),
			$entite->{'psi_pval'},
			# Autres algos
			($SI_ok) ? 'X' : '',
			($SIsd_ok) ? 'X' : ''
		);

		# On affiche les data
		for(my $j = 0; $j < @data; $j++){

			# $i + 1 parce que la premiere ligne est l'entete
			$f->write($nb_lignes, $j, $data[$j], $format);

		}

		$nb_lignes++;

	}

}
